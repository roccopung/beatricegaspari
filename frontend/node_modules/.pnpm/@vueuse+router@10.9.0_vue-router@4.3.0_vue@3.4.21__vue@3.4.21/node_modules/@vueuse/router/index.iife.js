var VueDemi = (function (VueDemi, Vue, VueCompositionAPI) {
  if (VueDemi.install) {
    return VueDemi
  }
  if (!Vue) {
    console.error('[vue-demi] no Vue instance found, please be sure to import `vue` before `vue-demi`.')
    return VueDemi
  }

  // Vue 2.7
  if (Vue.version.slice(0, 4) === '2.7.') {
    for (var key in Vue) {
      VueDemi[key] = Vue[key]
    }
    VueDemi.isVue2 = true
    VueDemi.isVue3 = false
    VueDemi.install = function () {}
    VueDemi.Vue = Vue
    VueDemi.Vue2 = Vue
    VueDemi.version = Vue.version
    VueDemi.warn = Vue.util.warn
    VueDemi.hasInjectionContext = function() {
      return !!VueDemi.getCurrentInstance()
    }
    function createApp(rootComponent, rootProps) {
      var vm
      var provide = {}
      var app = {
        config: Vue.config,
        use: Vue.use.bind(Vue),
        mixin: Vue.mixin.bind(Vue),
        component: Vue.component.bind(Vue),
        provide: function (key, value) {
          provide[key] = value
          return this
        },
        directive: function (name, dir) {
          if (dir) {
            Vue.directive(name, dir)
            return app
          } else {
            return Vue.directive(name)
          }
        },
        mount: function (el, hydrating) {
          if (!vm) {
            vm = new Vue(Object.assign({ propsData: rootProps }, rootComponent, { provide: Object.assign(provide, rootComponent.provide) }))
            vm.$mount(el, hydrating)
            return vm
          } else {
            return vm
          }
        },
        unmount: function () {
          if (vm) {
            vm.$destroy()
            vm = undefined
          }
        },
      }
      return app
    }
    VueDemi.createApp = createApp
  }
  // Vue 2.6.x
  else if (Vue.version.slice(0, 2) === '2.') {
    if (VueCompositionAPI) {
      for (var key in VueCompositionAPI) {
        VueDemi[key] = VueCompositionAPI[key]
      }
      VueDemi.isVue2 = true
      VueDemi.isVue3 = false
      VueDemi.install = function () {}
      VueDemi.Vue = Vue
      VueDemi.Vue2 = Vue
      VueDemi.version = Vue.version
      VueDemi.hasInjectionContext = function() {
        return !!VueDemi.getCurrentInstance()
      }
    } else {
      console.error('[vue-demi] no VueCompositionAPI instance found, please be sure to import `@vue/composition-api` before `vue-demi`.')
    }
  }
  // Vue 3
  else if (Vue.version.slice(0, 2) === '3.') {
    for (var key in Vue) {
      VueDemi[key] = Vue[key]
    }
    VueDemi.isVue2 = false
    VueDemi.isVue3 = true
    VueDemi.install = function () {}
    VueDemi.Vue = Vue
    VueDemi.Vue2 = undefined
    VueDemi.version = Vue.version
    VueDemi.set = function (target, key, val) {
      if (Array.isArray(target)) {
        target.length = Math.max(target.length, key)
        target.splice(key, 1, val)
        return val
      }
      target[key] = val
      return val
    }
    VueDemi.del = function (target, key) {
      if (Array.isArray(target)) {
        target.splice(key, 1)
        return
      }
      delete target[key]
    }
  } else {
    console.error('[vue-demi] Vue version ' + Vue.version + ' is unsupported.')
  }
  return VueDemi
})(
  (this.VueDemi = this.VueDemi || (typeof VueDemi !== 'undefined' ? VueDemi : {})),
  this.Vue || (typeof Vue !== 'undefined' ? Vue : undefined),
  this.VueCompositionAPI || (typeof VueCompositionAPI !== 'undefined' ? VueCompositionAPI : undefined)
);
;
;(function (exports, vueDemi, vueRouter, shared) {
  'use strict';

  let _hash;
  function useRouteHash(defaultValue, {
    mode = "replace",
    route = vueRouter.useRoute(),
    router = vueRouter.useRouter()
  } = {}) {
    _hash = route.hash;
    shared.tryOnScopeDispose(() => {
      _hash = void 0;
    });
    let _trigger;
    const proxy = vueDemi.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return _hash || shared.toValue(defaultValue);
        },
        set(v) {
          if (v === _hash)
            return;
          _hash = v === null ? void 0 : v;
          trigger();
          vueDemi.nextTick(() => {
            const { params, query } = route;
            router[shared.toValue(mode)]({ params, query, hash: _hash });
          });
        }
      };
    });
    vueDemi.watch(
      () => route.hash,
      () => {
        _hash = route.hash;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  const _queue$1 = /* @__PURE__ */ new WeakMap();
  function useRouteParams(name, defaultValue, options = {}) {
    const {
      mode = "replace",
      route = vueRouter.useRoute(),
      router = vueRouter.useRouter(),
      transform = (value) => value
    } = options;
    if (!_queue$1.has(router))
      _queue$1.set(router, /* @__PURE__ */ new Map());
    const _paramsQueue = _queue$1.get(router);
    let param = route.params[name];
    shared.tryOnScopeDispose(() => {
      param = void 0;
    });
    let _trigger;
    const proxy = vueDemi.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return transform(param !== void 0 ? param : shared.toValue(defaultValue));
        },
        set(v) {
          if (param === v)
            return;
          param = v === defaultValue || v === null ? void 0 : v;
          _paramsQueue.set(name, v === defaultValue || v === null ? void 0 : v);
          trigger();
          vueDemi.nextTick(() => {
            if (_paramsQueue.size === 0)
              return;
            const newParams = Object.fromEntries(_paramsQueue.entries());
            _paramsQueue.clear();
            const { params, query, hash } = route;
            router[shared.toValue(mode)]({
              params: {
                ...params,
                ...newParams
              },
              query,
              hash
            });
          });
        }
      };
    });
    vueDemi.watch(
      () => route.params[name],
      (v) => {
        param = v;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  const _queue = /* @__PURE__ */ new WeakMap();
  function useRouteQuery(name, defaultValue, options = {}) {
    const {
      mode = "replace",
      route = vueRouter.useRoute(),
      router = vueRouter.useRouter(),
      transform = (value) => value
    } = options;
    if (!_queue.has(router))
      _queue.set(router, /* @__PURE__ */ new Map());
    const _queriesQueue = _queue.get(router);
    let query = route.query[name];
    shared.tryOnScopeDispose(() => {
      query = void 0;
    });
    let _trigger;
    const proxy = vueDemi.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return transform(query !== void 0 ? query : shared.toValue(defaultValue));
        },
        set(v) {
          if (query === v)
            return;
          query = v === defaultValue || v === null ? void 0 : v;
          _queriesQueue.set(name, v === defaultValue || v === null ? void 0 : v);
          trigger();
          vueDemi.nextTick(() => {
            if (_queriesQueue.size === 0)
              return;
            const newQueries = Object.fromEntries(_queriesQueue.entries());
            _queriesQueue.clear();
            const { params, query: query2, hash } = route;
            router[shared.toValue(mode)]({
              params,
              query: { ...query2, ...newQueries },
              hash
            });
          });
        }
      };
    });
    vueDemi.watch(
      () => route.query[name],
      (v) => {
        query = v;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  exports.useRouteHash = useRouteHash;
  exports.useRouteParams = useRouteParams;
  exports.useRouteQuery = useRouteQuery;

})(this.VueUse = this.VueUse || {}, VueDemi, VueRouter, VueUse);

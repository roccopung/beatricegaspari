'use strict';

var vueDemi = require('vue-demi');
var vueRouter = require('vue-router');
var shared = require('@vueuse/shared');

let _hash;
function useRouteHash(defaultValue, {
  mode = "replace",
  route = vueRouter.useRoute(),
  router = vueRouter.useRouter()
} = {}) {
  _hash = route.hash;
  shared.tryOnScopeDispose(() => {
    _hash = void 0;
  });
  let _trigger;
  const proxy = vueDemi.customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        return _hash || shared.toValue(defaultValue);
      },
      set(v) {
        if (v === _hash)
          return;
        _hash = v === null ? void 0 : v;
        trigger();
        vueDemi.nextTick(() => {
          const { params, query } = route;
          router[shared.toValue(mode)]({ params, query, hash: _hash });
        });
      }
    };
  });
  vueDemi.watch(
    () => route.hash,
    () => {
      _hash = route.hash;
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

const _queue$1 = /* @__PURE__ */ new WeakMap();
function useRouteParams(name, defaultValue, options = {}) {
  const {
    mode = "replace",
    route = vueRouter.useRoute(),
    router = vueRouter.useRouter(),
    transform = (value) => value
  } = options;
  if (!_queue$1.has(router))
    _queue$1.set(router, /* @__PURE__ */ new Map());
  const _paramsQueue = _queue$1.get(router);
  let param = route.params[name];
  shared.tryOnScopeDispose(() => {
    param = void 0;
  });
  let _trigger;
  const proxy = vueDemi.customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        return transform(param !== void 0 ? param : shared.toValue(defaultValue));
      },
      set(v) {
        if (param === v)
          return;
        param = v === defaultValue || v === null ? void 0 : v;
        _paramsQueue.set(name, v === defaultValue || v === null ? void 0 : v);
        trigger();
        vueDemi.nextTick(() => {
          if (_paramsQueue.size === 0)
            return;
          const newParams = Object.fromEntries(_paramsQueue.entries());
          _paramsQueue.clear();
          const { params, query, hash } = route;
          router[shared.toValue(mode)]({
            params: {
              ...params,
              ...newParams
            },
            query,
            hash
          });
        });
      }
    };
  });
  vueDemi.watch(
    () => route.params[name],
    (v) => {
      param = v;
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

const _queue = /* @__PURE__ */ new WeakMap();
function useRouteQuery(name, defaultValue, options = {}) {
  const {
    mode = "replace",
    route = vueRouter.useRoute(),
    router = vueRouter.useRouter(),
    transform = (value) => value
  } = options;
  if (!_queue.has(router))
    _queue.set(router, /* @__PURE__ */ new Map());
  const _queriesQueue = _queue.get(router);
  let query = route.query[name];
  shared.tryOnScopeDispose(() => {
    query = void 0;
  });
  let _trigger;
  const proxy = vueDemi.customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        return transform(query !== void 0 ? query : shared.toValue(defaultValue));
      },
      set(v) {
        if (query === v)
          return;
        query = v === defaultValue || v === null ? void 0 : v;
        _queriesQueue.set(name, v === defaultValue || v === null ? void 0 : v);
        trigger();
        vueDemi.nextTick(() => {
          if (_queriesQueue.size === 0)
            return;
          const newQueries = Object.fromEntries(_queriesQueue.entries());
          _queriesQueue.clear();
          const { params, query: query2, hash } = route;
          router[shared.toValue(mode)]({
            params,
            query: { ...query2, ...newQueries },
            hash
          });
        });
      }
    };
  });
  vueDemi.watch(
    () => route.query[name],
    (v) => {
      query = v;
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

exports.useRouteHash = useRouteHash;
exports.useRouteParams = useRouteParams;
exports.useRouteQuery = useRouteQuery;
